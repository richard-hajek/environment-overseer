#!/usr/bin/python

import argparse
import itertools
import os
import sched
import signal
import time
from shutil import copyfile
import psutil

parser = argparse.ArgumentParser(description="Controls the environment overseer")
parser.add_argument('-e', '--enable', nargs='+', help='Enables an activity')
parser.add_argument('-d', '--disable', nargs='+', help='Disables an activity')
parser.add_argument('-r', '--reset', action='store_true', help='Reset all timers')
parser.add_argument('-w', '--write', action='store_true', help='Write usage to history')
parser.epilog = "Exit Codes: 0: success / 1: daemon not running / 2: not running as root"
args = parser.parse_args()

enabled_activities = []
bumped_at = -1
timer = sched.scheduler(time.time, time.sleep)

overseer_home = "/etc/environment-overseer"
archive_path = "/root/overseer-archive/"


def sigusr(_, __):
    bump()


def sigusr2(_, __):
    reset_timers()


def link_enable(activity):
    if not os.path.islink(f"active/{activity}"):
        os.symlink(f"today/{activity}", f"active/{activity}")


def link_disable(activity):
    if os.path.islink(f"active/{activity}"):
        os.remove(f"active/{activity}")


def write_history():
    today_dir = time.strftime("%d_%m_%Y")

    if not os.path.isdir(f"{archive_path}/{today_dir}"):
        os.mkdir(f"{archive_path}/{today_dir}")

    for activity in os.listdir("today"):
        copyfile(f"today/{activity}", f"{archive_path}/{today_dir}/{activity}")


def reset_timers():
    """
    Restart the tracked times
    :return:
    """
    for f in os.listdir("today"):
        os.remove(f"today/{f}")

    for f in os.listdir("active"):
        os.remove(f"active/{f}")

    for activity in os.listdir("limits"):
        with open(f"today/{activity}", 'w') as file:
            file.write('0')


def bump(force_run=False):
    """
    Searches for newly enabled / disabled activities
    Searches for activities which ran out of time

    Updates files for active activities

    :param force_run: Forces bump to run disable or enable scripts of all activities
    """
    create_all_records()
    global bumped_at
    print("----Bumping----")
    activities = os.listdir("today")
    active = os.listdir("active")

    just_enabled = []
    just_disabled = []

    # --------------------------------------------
    # - FIND NEWLY ENABLED / DISABLED ACTIVITIES -
    # --------------------------------------------
    for activity in active:
        if not enabled_activities.__contains__(activity):
            just_enabled.append(activity)
            enabled_activities.append(activity)

    for activity in enabled_activities:
        if not active.__contains__(activity):
            just_disabled.append(activity)
            enabled_activities.remove(activity)

    # --------------------------------------------
    # - CALCULATING NEW TIMES                    -
    # --------------------------------------------
    time_passed = time.time() - bumped_at
    for activity in itertools.chain(enabled_activities, just_disabled):

        if just_enabled.__contains__(activity):
            continue

        activity_time = get_activity_time(activity) + time_passed
        update_time(activity, activity_time)

    for activity in enabled_activities:
        if get_activity_time(activity) > get_limit(activity):
            just_disabled.append(activity)
            enabled_activities.remove(activity)

    bumped_at = time.time()

    # --------------------------------------------
    # - RUNNING ENABLE / DISABLE SCRIPTS         -
    # --------------------------------------------
    for activity in activities:
        if just_enabled.__contains__(activity) and just_disabled.__contains__(activity):
            just_enabled.remove(activity)
            just_disabled.remove(activity)
        if not just_enabled.__contains__(activity) and not just_disabled.__contains__(activity) and force_run:
            just_disabled.append(activity)

    for activity in just_enabled:
        run(activity, "enable")

    for activity in just_disabled:
        run(activity, "disable")
        if os.path.islink(f"active/{activity}"):
            os.remove(f"active/{activity}")

    # --------------------------------------------
    # - TIMING NEXT BUMP                         -
    # --------------------------------------------
    for event in timer.queue:
        timer.cancel(event)

    next_bump = 60
    for activity in enabled_activities:
        time_left = get_limit(activity) - get_activity_time(activity)
        if time_left < next_bump:
            next_bump = time_left

    print(f"Scheduling next bump in {next_bump} seconds")
    timer.enter(next_bump, 1, bump)


def run(activity, action):
    print(f"Running {action} for {activity}")
    os.system(f"scripts/{action}/{activity}")


def get_limit(activity):
    path = f"limits/{activity}"
    with open(path, 'r') as content_file:
        limit = content_file.read()
    limit = float(limit)
    return limit


def get_activity_time(activity):
    path = f"today/{activity}"
    with open(path, 'r') as content_file:
        time_spent = content_file.read()
    time_spent = float(time_spent)
    return time_spent


def create_all_records():
    for activity in os.listdir("limits"):
        create_record_if_non_existent(activity)


def create_record_if_non_existent(activity):
    path = f"today/{activity}"

    if os.path.isfile(path):
        return

    with open(path, 'w') as content_file:
        content_file.write('0')


def update_time(activity, time_passed):
    f = open(f"today/{activity}", 'w')
    f.write(str(time_passed))
    f.close()


def create_folders_if_non_existent():

    if not os.path.isdir(overseer_home):
        os.mkdir(overseer_home)
    if not os.path.isdir("active"):
        os.mkdir("active")
    if not os.path.isdir("today"):
        os.mkdir("today")
    if not os.path.isdir("scripts"):
        os.mkdir("scripts")
        os.mkdir("scripts/enable")
        os.mkdir("scripts/disable")
    if not os.path.isdir("limits"):
        os.mkdir("limits")


def remote_bump():
    with open("/tmp/overseer.pid", 'r') as content_file:
        pid = content_file.read()
        pid = int(pid)
        os.kill(pid, signal.SIGUSR1)


def remote_reset():
    with open("/tmp/overseer.pid", 'r') as content_file:
        pid = content_file.read()
        pid = int(pid)
        os.kill(pid, signal.SIGUSR2)


def is_daemon_running():

    if not os.path.isfile("/tmp/overseer/pid"):
        return False

    with open("/tmp/overseer.pid", 'r') as content_file:
        pid = content_file.read()
        pid = int(pid)

        if psutil.pid_exists(pid):
            return True
        else:
            return False


def is_privileged():
    return os.getuid() == 0


# Preparation
start_daemon = not args.enable and \
               not args.disable and \
               not args.write and \
               not args.reset

if args.enable:

    if not is_daemon_running():
        print("You must launch the daemon first!")
        exit(1)

    if not is_privileged():
        print("You must run as root user!")
        exit(2)

    print("Enabling activities...")
    os.chdir(overseer_home)
    for a in args.enable:
        link_enable(a)
    remote_bump()

if args.disable:

    if not is_daemon_running():
        print("You must launch the daemon first!")
        exit(1)

    if not is_privileged():
        print("You must run as root user!")
        exit(2)

    print("Disabling activities...")
    os.chdir(overseer_home)
    for a in args.disable:
        link_disable(a)
    remote_bump()

if args.write:

    if not is_daemon_running():
        print("You must launch the daemon first!")
        exit(1)

    if not is_privileged():
        print("You must run as root user!")
        exit(2)

    print("Writing to history...")
    os.chdir(overseer_home)
    write_history()

if args.reset:

    if not is_daemon_running():
        print("You must launch the daemon first!")
        exit(1)

    if not is_privileged():
        print("You must run as root user!")
        exit(2)

    print("Resetting limits...")
    os.chdir(overseer_home)
    remote_reset()

if start_daemon:
    print("Starting as daemon...")

    create_folders_if_non_existent()
    create_all_records()
    os.chdir(overseer_home)

    signal.signal(signal.SIGUSR1, sigusr)
    signal.signal(signal.SIGUSR2, sigusr2)
    bump(force_run=True)
    with open("/tmp/overseer.pid", "w") as pidf:
        pidf.write(str(os.getpid()))
        pidf.close()
    timer.run()
